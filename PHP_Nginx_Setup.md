# Setting up Nginx to use PHP

## PHP Setup

### Installation
```
sudo yum install php php-mysql php-fpm
```

### Configure the PHP Processor
Open the main php-fpm configuration file with root privileges:
```
sudo vi /etc/php.ini
```
What we are looking for in this file is the parameter that sets cgi.fix_pathinfo. This will be commented out with a semi-colon (;) and set to "1" by default.

This is an extremely insecure setting because it tells PHP to attempt to execute the closest file it can find if a PHP file does not match exactly. This basically would allow users to craft PHP requests in a way that would allow them to execute scripts that they shouldn't be allowed to execute.

We will change both of these conditions by uncommenting the line and setting it to "0" like this:
```
cgi.fix_pathinfo=0
```
Save and close the file when you are finished.

Next, open the php-fpm configuration file ```www.conf```:
```
sudo vi /etc/php-fpm.d/www.conf
```
Find the line that specifies the listen parameter, and change it so it looks like the following:
```
listen = /var/run/php-fpm/php-fpm.sock
```
Then save and quit.

Now, we just need to start our PHP processor by typing:
```
sudo systemctl start php-fpm
```
This will implement the change that we made.

Next, enable php-fpm to start on boot:
```
sudo systemctl enable php-fpm.service
```


## Configure Nginx to Process PHP Pages

Now, we have all of the required components installed. The only configuration change we still need to do is tell Nginx to use our PHP processor for dynamic content.

We do this on the server block level (server blocks are similar to Apache's virtual hosts). Open the default Nginx server block configuration file by typing:
```
sudo vi /etc/nginx/conf.d/default.conf
```
Currently, with the comments removed, the Nginx default server block looks like this:
```
server {
    listen       80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```
We need to make some changes to this file for our site.

- First, we need to add an index.php option as the first value of our index directive to allow PHP index files to be served when a directory is requested

- We also need to modify the server_name directive to point to our server's domain name or public IP address

- The actual configuration file includes some commented out lines that define error processing routines. We will uncomment those to include that functionality

- For the actual PHP processing, we will need to uncomment a portion of another section. We will also need to add a try_files directive to make sure Nginx doesn't pass bad requests to our PHP processor

The changes that you need to make are in red in the text below:
```
server {
    listen       80;
    server_name  server_domain_name_or_IP;

    root   /usr/share/nginx/html;
    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ =404;
    }
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```
When you've made the above changes, you can save and close the file.

Restart Nginx to make the necessary changes:
```
sudo systemctl restart nginx
```


## Test PHP Processing on your Web Server

In order to test that our system is configured properly for PHP, we can create a very basic PHP script.

We will call this script info.php. In order for Apache to find the file and serve it correctly, it must be saved to a very specific directory, which is called the "web root".

In CentOS 7, this directory is located at /usr/share/nginx/html/. We can create the file at that location by typing:
```
sudo vi /usr/share/nginx/html/info.php
```
This will open a blank file. We want to put the following text, which is valid PHP code, inside the file:
```
<?php phpinfo(); ?>
```
When you are finished, save and close the file.

Now we can test whether our web server can correctly display content generated by a PHP script. To try this out, we just have to visit this page in our web browser. You'll need your server's public IP address again.

The address you want to visit will be:
```
http://your_server_IP_address/info.php
```

This page basically gives you information about your server from the perspective of PHP. It is useful for debugging and to ensure that your settings are being applied correctly.

If this was successful, then your PHP is working as expected.

You probably want to remove this file after this test because it could actually give information about your server to unauthorized users. To do this, you can type this:
```
sudo rm /usr/share/nginx/html/info.php
```
You can always recreate this page if you need to access the information again later.


## Solve Nginx: stat() failed (13: permission denied)

Nginx operates within the direcotry, so if you can't ```cd``` to that directory from the nginx user then it will fail (as does the stat command in your log). 
Make sure the <NGINX USER> can ```cd``` all the way to the DIRECTORY. 
You can confirm that the stat will fail or succeed by running

```
sudo -u <NGINX USER> stat <DIRECTORY PATH>
```

Usually the ```<NGINX USER>```  is ```nginx```

The best solution in that case would be to add <NGINX USER> to user group which owns the directory:

```
gpasswd -a <NGINX USER> <OWNER USERNAME>
```
and make sure that username group can enter all directories along the path:

```
chmod g+x /home/<OWNER USERNAME>/
```



## Sample Nginx Configuration for managing multiple hosts (Virtual Hosts) within the same Server

You may create multiple configuration files under 

```
/etc/nginx/conf.d/
```

### Server plain HTML files from http://www.ABC.com/

```
server {
    listen         80;
    server_name    ABC.com www.ABC.com *.ABC.com;

    root           /home/ABC/html;
    index index.php index.html index.htm;
    
    error_log  /home/ABC/logs/nginx_error_log.txt  warn;

    location / {

    }
}

```

### Serve PHP files from http://www.ABC.com/

```
server {
    listen       80;
    server_name  ABC.com www.ABC.com *.ABC.com;

    root         /home/ABC/html/;
    index        index.php index.html index.htm;

    location     / {
        try_files $uri $uri/ =404;
    }

    error_page    404 /404.html;
    error_page    500 502 503 504 /50x.html;
    location       /50x.html {
        root   /usr/share/nginx/html;
    }
    error_log    /ABC/logs/nginx_error_log.txt  error;

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```

## Proxy Connection to NodeJS Servers

```
server {
    listen         80;
    server_name    ABC.com www.ABC.com *.ABC.com;

    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    location /api {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    location /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

## Basic Authentication with Nginx
adapted from (http://roger.steneteg.org/441/basic-authentication-with-nginx/)

In order to prevent public access to your web site a basic protection method available is Basic Authentication. Basic Authentication uses credentials which is sent along the http request in the http header.

When a user sends a http request to a url which is protected with basic authentication the server will send back a **401 Not authorized** response with the **“WWW-Authenticate”** header set. The web browser will then prompt the user with a username and password dialog which will be added to the request.

Then the browser will resend the http request with the **“Authorization”** header set. The authorization header value consist of a string which specifies the authentication method that is used, for basic authentication this would be **“Basic”** and then a base64 encoded string containing the username and password in this format **“username:password“**.

The server will see that the request contains a Authorization header and decode the username and password and use that to authenticate the user.

Remember that the base64 encoded string does not provide any encryption, so the username and password will basically be sent along the request in clear text, which makes it very vulnerable to eavesdropping. So if you are going to use basic authentication the http trafic should be protected by using SSL encryption.

 

To configure Nginx to use basic authentication you need to add the following configuration to either **http, server, location or limit_except** context:

```
auth_basic "Restricted Access"; 
auth_basic_user_file /path/to/.htpasswd;
```

The **“Restricted Access”** string will be shown on the credentials prompt dialog for the user and can be set to whatever you want. The path to the **.htpasswd** file can either be an absolute path like I use, or a path relative to the directory containing your nginx.conf file.

You can read more about these parameters here http://wiki.nginx.org/HttpAuthBasicModule

The .htpasswd file should contain the valid usernames and password in the **username:password:comment** format separated by newlines.

The passwords should be in an encoded format, here is how to generate passwords in the different available formats:

    # default encryption method for Nginx 
        openssl passwd -crypt <password>
        
    # Apache default htpasswd format 
        openssl passwd -apr1 <password>
        
    # A BSD based MD5 format 
        openssl passwd -1 <password>
        
    # SSHA format 
        (PASSWORD="<password>";SALT="$(openssl rand -base64 3)";SHA1=$(printf "$PASSWORD$SALT" | openssl dgst -binary -sha1 | sed 's#$#'"$SALT"'#' | base64);printf "{SSHA}$SHA1\n")
